# 나의

1. 주어진 와일드카드 문자열을 \*를 구분자로 여러 조각으로 나눈다.
2. 여기서, 첫 번째 조각과 파일명의 시작 부분부터 대조한다.
3. 조각이 매치되는 경우가 있다면, 파일명의 나머지 부분에서 다음 와일드카드 조각을 대조하기 시작한다.

Greedy적인 관점에서, 한 조각이 여러 부분에서 매치된다면, 남는 부분이 가장 크게 하는 것이 옳다. (즉, 가장 앞에서 매치되게 하는게 옳다)

# 종만씨의

1. 앞에서부터 매치를 시작한다.
2. \*을 만나면 **전체적으로 옳은**경우를 발견할때까지 재귀 호출을 시작한다
3. 이 과정에서 캐싱을 한다.

가령,

> 1번째 조각이 1번, 2번째 조각이 5번, 3번째 조각이 15번에 매치되는 경우

가

> 1번째 조각이 1번, 2번째 조각이 8번, 3번째 조각이 15번에 매치되는 경우

와 중복된다.

# 결론적으로

내 방법이 더 좋을 것이다. 단, 구현만 가능하다면

### 일단 구현해보자 그리고, 시간복잡도를 계산해보자

내 생각이 너무 느릴거라고 생각했다. 왜냐면 DP문제에서 캐싱을 사용하지 않았기 때문이다. 하지만 난 캐싱이 필요 없는, 언제나 더 좋은 방향의 로직을 생각한거다. 그렇다면 왜 종만씨는 이 방법을 사용하지 않았을까?

- Greedy는 뒷장에서 다룰 예정이다.
- 내 생각은 구현하기에 너무 복잡하다.
- Greedy를 구현한 결과물이, 반복문이나 재귀의 복잡도로 실제적으론 더 느리다.

위 3가지 중 하나가 이유이지 않을까?

어찌 되었든 내 방법은 도전해볼 가치가 있었지만, 그 전에 포기하고 답을 봐버렸다. 여기서 드는 생각.

| 난 현상을 스스로 판단해서 결론내는가. 아니면 남이 내린 결론에 현상을 맞춰 분석하는가?
